export interface LoggerInterface {
    debug: (...params: any[]) => any;
}
export interface InjectableInterface {
    inject: (...args: any[]) => any;
}
export declare type SubscriberCallbackParams = {
    serviceLocator: DiContainer;
    params: any[];
};
export declare type SubscriptionsDict = {
    [k: string]: (param: SubscriberCallbackParams) => any;
};
export declare type GetInstanceType<C> = C extends new (...args: any[]) => infer T ? T : never;
export declare type GetInjectableSubclass<T> = T extends InjectableInterface ? T : never;
export declare type AfterCallbackProps<T> = {
    me: T;
    serviceLocator: DiContainer;
    el: LoadDictElement<T>;
    deps: DependenciesDict;
};
export declare type BeforeCallbackProps<T> = {
    serviceLocator: DiContainer;
    el: LoadDictElement<T>;
    deps: DependenciesDict;
};
export declare type LoadDictElement<T = any> = {
    constructible?: new (...args: any[]) => T;
    instance?: T;
    injectable?: GetInjectableSubclass<T>;
    deps?: DependenciesDict;
    destructureDeps?: boolean;
    locateDeps?: LocatableNestedDependenciesDict;
    after?: (props: AfterCallbackProps<T>) => (T | void | Promise<T | void>);
    before?: (props: BeforeCallbackProps<T>) => (DependenciesDict | void | Promise<DependenciesDict | void>);
    factory?: (...args: any[]) => T;
    subscriptions?: SubscriptionsDict;
};
export declare type LoadDict = {
    [P: string]: LoadDictElement;
};
export declare type LoadPromisesDict = {
    [k: string]: Promise<any>;
};
export declare type ServiceLocatorDict = {
    [k: string]: any;
};
export declare type DependenciesDict = ServiceLocatorDict;
export declare type LocatableNestedDependenciesDict = {
    [k: string]: string | LocatableNestedSubDependenciesDict;
};
export declare type LocatableNestedSubDependenciesDict = {
    [k: string]: string | LocatableNestedSubDependenciesDict;
} | {
    [i: number]: string | LocatableNestedSubDependenciesDict;
};
declare class DiContainer {
    logger: LoggerInterface;
    locatorRefDict: ServiceLocatorDict;
    loadDict: LoadDict;
    loading: boolean;
    loadPromises: LoadPromisesDict;
    constructor({ logger, load }: {
        logger?: LoggerInterface;
        load?: LoadDict;
    });
    loadAll(injectionDict?: LoadDict): Promise<boolean>;
    addToLoadDict(injectionDict: LoadDict): void;
    addToLoadingPromisesIfNotAlreadyThere(refName: string, promise: Promise<any>): boolean;
    deepLocateDeps(locateDeps: LocatableNestedDependenciesDict): Promise<{
        [x: string]: any;
    }>;
    mergeObjects(a: any, b: any): any;
    load(refName: string): Promise<any>;
    get<T = any>(refName: string): Promise<T>;
    getLoadPromise(refName: string): Promise<any>;
    set(refName: string, val: any): any;
    has(refName: string): boolean;
    isValidRefNameOrThrow(refName: string): void;
    emit(eventName: string, ...params: any[]): Promise<void>;
    static inject({ logger }: {
        logger: LoggerInterface;
    }): void;
    static getLatestContainer(): DiContainer;
    static getFirstContainer(): DiContainer;
    static getNthContainer(n: number): DiContainer;
    static getContainers(): DiContainer[];
}
export default DiContainer;
//# sourceMappingURL=DiContainer.d.ts.map